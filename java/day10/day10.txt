Unit이라는 클래스를 통하여 공통 속성을 정의하고 있다
- 공통속성: 이름(멤버변수 및 getter, setter) 공격(attack()메서드)
- 같은이름이지만 다른 동작을 수행해야 하는 필요성
	모든 군대는 공격 하지만 방법이 다름
- 부모 클래스가 가지고 있는 기능을 자식클래스가 재정의
	부모클래스에 정의된 것과 동일한 이름을 갖는 메서드를 자식클래스에서 정의한 경우
	부모 클래스의 기능이 가려짐
	이것을 Override라고 함
- 하나의 이름으로 다양한 효과

1-1 super 키워드
 -클래스의 상속 관계에서 자식 클래스가 부모 클래스를 가르키는 예약어
 -사용방법
	->멤버변수 이름 앞에 명시
	:부모 클래스의 멤버변수를 의미한다 하지만 부모클래스의 멤버변수는
	 이미 모두 상속되어 있기 때문에 이 경우에는 this 키워드를 사용하는
	 것과 동일한 결과이기에 잘 사용하지 않는다
	
	> 메서드 이름 앞에 명시
	 : 부모클래스의 메서드를 의미
	 : 재정의(Override) 되지않은 메서드
	 - 이미 상속되어 있기 때문에 this 키워드를사용하는 것과 동일한 결과 

	 : 재정의(Override) 되지않은 메서드
	 - Override된 메서드 이름 앞에 사용하게 되면 재정의되기 이전의
	  원본 메서드를 의미한다.

	-> 키워드 자체를 메서드처럼 이용
	  :super();
	  :부모클래스의 생성자를 의미한다

1-2. 상속 관계에서의 생성자 처리
	-생성자가 정의된 클래스의 상속 제한
	-생성자는 상속되지 않는다
	-하지만 생성자가 정의된 클래스는 객체 생성을 위해서 생성자 파라미터를 반드시
	 전달받아야 하기 때문에, 파라미터를 갖는 생성자가 정의된 클래스를 상속받게 되면
	 에러가 발생된다.

	-부모 생성자의 강제 호출
		->생성자가 정의된 클래스를 상속받은 경우에는 자식 클래스의 생성자를
		부모 생성자를 강제호출해야함
		-> 부모의 생성자를 호출하는 방법은 super 키워드를 메서드 이름으로 
		사용하는 것이다.

unit Armt 를 참고하여
Navy airforce
main 메서드가 포함된 클래스에서
육해공 객체 생성해서
attack() 호출


1-3. 메서드 재정의 과정에서 오타가 발생한 경우
	부모 클래스의 say() 메서드를 재정의 하는 과정에서 개발자의 실수로 인해
	sai()라고 메서드가 추가되었다면, java는 새로운 메서드를 추가한 것으로 인식하고
	특별한 에러를 표시하지 않는다
	say()메서드가 재정의 된 것을 생각한 개발자는 이 경우 의도하지 않은 결과를 
	만나게 될 것이다.

1-4 @Override 옵션
	@Override 은 이 키워드가 명시된 위치 아래에 정의되는 메서드가 부모 클래스에
	존재하지 않을 경우 구문 에러로 처리한다
	부모 클래스의 메서드를 재정의 하고자 할 경우 의도치 않은 실수를 예방하기 위한
	'오타 방지 옵션' 이다
	여러개 의 메서드를 재정의 한다면 재정의 되는 모든 메서드를 위에 각기 명시해야 한다


































